# Приветствую вас, товарищи!
Время идёт, технологии развиваются, а вместе с этим появляются новые подходы к разработке. То же самое касается и дополнений.
Давайте разберёмся, что такое компоненты и почему это может заменить классические объекты элементов.

Данная библиотека будет работать только в случае сборки мода при помощи средств TypeScript, поэтому учитывайте это.

## Компоненты
Компоненты - это функции, которые возвращают xml разметку. После транспиляции мода разметка пропадает, заменяясь вызовами функций, которые возвращают объекты. Можно сказать, что компоненты - синтаксический сахар и способ сокращать код.

## Синтаксические особенности

Значения аттрибутов по-умолчанию принимают только строки, поэтому все остальные значения будут писаться внутри фигурных скобок.

Например числа будут записаны так: 
```tsx
<x={10} y={10}>
```

Объекты так:
```tsx
<font={{ size: 30 }}>
```  

В случае, если компоненты ничего не принимают, их можно записать короче:
```tsx
<Component/>
```

## Виды
У нас есть два вида компонентов. Используются они похожим образом, но всё же разные.

### Фиксированные:
Такие компоненты заточены под конкретный именованный ключ, возвращают объект в котором данные лежат под указанным названием в теге.

Напишем компонент:
```tsx
const Cat = () => (
    <picture type="image" x={0} y={0}>example/cat</picture>
);
```
В итоге мы получим такой объект:
```js
{
    picture: {
        type: "image",
        bitmap: "example/cat",
        x: 0,
        y: 0
    }
}
```
### Свободные
Такие компоненты могут как не иметь ключа и сразу представлять данные, так и подставлять ключи из переданных данных. В данных компонентах не нужно давать названия элементам в виде тега, достаточно абстрактно обозначить как `element`.

Напишем компонент:
```ts
const Meow = () => (
    return <element type="text">Мяу!</element>
);
```
В таком представлении он сразу вернёт конкретные данные. Давайте посмотрим на них:
```js
{
    type: "text",
    text: "Мяу!"
}
```
Теперь давайте попробуем прийти к результату, похожему при самом первом компоненте:
```tsx
const Meow = () => (
    return <element type="text" key="meow">Мяу!</element>
);
```
В таком представлении мы получим более результат, похожий на результат первого:
```tsx
{
    meow: {
        type: "text",
        text: "Мяу!"
    }
}
```
## Передача данных в компоненты:
Компоненты могут не просто строить данные на лету, они умеют делать это из чего угодно. Просто передайте нужные данные в виде аттрибутов или содержимого (child).

Создадим подобный компонент:
```tsx
const Title = (properties, child) => {
    return <element type="text" font={{ color: 0.375, size: 30 }} key={properties.key}>{ child }</element>
}
```
Передадим данные:
```js
const title = Title({
    key: "title"
}, "Привет, компонент!");
```
Посмотрим, что получилось в итоге:
```js
{
    title: {
        type: "text",
        font: { color: 0.375, size: 30 },
        text: "Привет, компонент!"
    }
}
```

## Встраивание компонентов
Одна из самых важных и интересных вещей :D

При помощи компонентов можно формировать полноценные группы элементов, которые потом можно сразу передавать в UI. 

Создадим сразу ряд компонентов, чтобы рассмотреть возможности:
```tsx
const Author = (properties, child) => (
    <author type="text" font={{ color: android.graphics.Color.BLACK, size: 15 }} x={200} y={50}>Автор: { child }</author>
);

const Tools = (properties, child) => (
    <tools type="text" font={{ size: 10 }} x={200} y={60}>Инструменты: { properties.tools.toString() }</tools>
);

const Mod = (properties, child) => (
    <mod type="text" font={{ size: 10 }} x={200} y={75}>Мод: { child }</mod>
);
```
Теперь создадим окно и компонент, который будет рисовать текст о нике автора, использованных инструментах и названии его мода.
```tsx
const window = new UI.Window();
const Project = () => (
    <> 
        <Author>ArtemKot</Author>
        <Tools tools={["EnergyNet", "ChargeItem", "SoundLib"]}></Tools>
        <Mod>Galacticraft 4</Mod>
    </>
);
window.setContent({
    elements: Project()
});
```

## Идентификаторы и автоматические позиции:
Компоненты хоть и позволяют удобно оформлять элементы, но это не единственный способ применения.
Они умеют самостоятельно вычислять свои позиции на основе предыдущих, принадлежащих к их типу, а так же ширины и высоты элемента, но только во время сборки списка элементов.

Помните, что в html у нас есть `margin-top, margin-bottom, margin-left, margin-right`? В компонентах есть то же самое, но сдвигает оно на юниты.

Давайте рассмотрим пример:
```tsx
const Adaptive = (properties, children) => (
    <element type="image" marginBottom={10} marginRight={10} width={50} height={50} key={children}>aboba</element>
);

const elements = (
    <>
        <Adaptive>A</Adaptive>
        <Adaptive>B</Adaptive>
    </>
)
```
Как выглядит объект elements?:
```js
{
    A: {
         type: "image",
        width: 50,
        height: 50,
        x: 0,
        y: 0,
        ...
    },
    B: {
        type: "image",
        width: 50,
        height: 50,
        x: 50 + 10,
        y: 50 + 10,
        ...
    }
}
```
Как мы видим, marginBottom опустил элемент на 10 юнитов, в то время marginRight сдвинул элемент на 10 юнитов вправо.

Что нам делать, если нам нужно, чтобы какие-то элементы могли разные отсчёты?

Нам на помощь приходят идентификаторы элементов (id). Они позволяют разделять элементы на категории, позиции которых вычисляются обособленно. Давайте посмотрим на примере:
```tsx
const Test = (properties, children) => (
    <element type="image" marginBottom={10} marginRight={10} width={50} height={50} key={children} id = {properties.id}>test</element>
);

const elementSet = (
    <>
        <Test>A</Test>
        <Test>B</Test>
        <Test id="aboba">O</Test>
        <Test>B_</Test>
        <Test id="aboba">A_</Test>
    </>
);
```
Итоговый объект:
```js
{
    A: {
        type: "image", marginBottom: 10, marginRight: 10,width: 70,height: 70, clicker: {}, bitmap: "test", x: 0, y: 0
    },
    B: {
        type: "image", marginBottom: 10, marginRight: 10, width: 70, height: 70, clicker: {}, bitmap: "test", x: 80, y: 80
    },
    O: {
        type: "image", marginBottom: 10, marginRight: 10, width: 70, height: 70, id: "aboba", clicker: {}, bitmap: "test", x: 0, y: 0
    },
    B_: {
        type: "image", marginBottom: 10, marginRight: 10, width: 70, height: 70, clicker: {}, bitmap: "test", x: 160, y: 160
    },
    A_: {
        type: "image", marginBottom: 10, marginRight: 10, width: 70, height: 70, id: "aboba", clicker: {}, bitmap: "test", x: 80, y: 80
    }
}
    
```

Давайте рассмотрим небольшую таблицу

| Вправо | Влево | Вверх | Вниз |
| :----: | :---: | :---: | :--: |
| marginRight | marginLeft | marginTop | marginBottom
| Увеличивает `x` на `n` | Уменьшает `x` на `n` | Уменьшает `y` на `n` | Увеличивает `x` на `n` | 

## Перестройка списка элементов
Как я и говорил ранее, элементы строятся лишь в момент создания объекта хранения.
Поэтому после того, как вы измените `x` или `y` у уже поставленного контента, остальные элементы не подвинутся.

У этой проблемы есть одно решение. Создать новый объект и заменить предыдущий на обновлённый, который учитывает все параметры прошлого, в том числе и изменённые параметры.

Давайте попробуем:
```tsx
const Text = (properties, children) => (
    <element type="text", marginBottom={10} key={children}>Пример</text>
)
const UI = new UI.Window({
    content: (
        <> 
            <Text>1</Text>
        </>
    )
});

//Давайте добавим новый элемент:
UI.content.elements.text2 = <Text>2</Text>;

//Перестроим:
UI.content.elements = UI.JSX.rebuildElementSet(UI.content.elements);
```
После этого позиции адаптируются.

## Подключение
1. Найдите в этой папке файл **settings.json**, содержащий настройки для транспилятора TypeScript;
2. Вставьте значения внутрь вашего tsconfig, а в случае тулчейна от автора Nernar добавьте поле **tsconfig** с значениями из файла settings.json в файл make.json;
3. Добавьте файл **Component.tsx** либо **Component.js** в ваш проект и объявите его в файле **.includes** или **tsconfig.json**;
4. Переименуйте расширения файлов, где будете использовать компоненты, в **tsx**;
5. Запустите задачу пересборки деклараций или поменяйте нужное вручную;
## Заключение
Если заинтересовало, обязательно пробуйте! Спасибо за чтение этого небольшого руководства, удачи вам в ваших начинаниях.